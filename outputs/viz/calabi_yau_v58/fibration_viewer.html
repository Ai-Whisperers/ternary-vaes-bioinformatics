<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calabi-Yau Fibration Viewer - v5.8 Extended (500 Fibers, 8 Projections)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Arial, sans-serif; background: #0a0a0f; color: #e0e0e0; overflow: hidden; }
        #container { width: 100vw; height: 100vh; }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(15, 15, 25, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            max-width: 340px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 100;
        }

        h1 { font-size: 16px; margin-bottom: 5px; color: #8af; }
        .subtitle { font-size: 11px; color: #666; margin-bottom: 15px; }
        h2 { font-size: 13px; margin: 15px 0 8px; color: #aaa; border-bottom: 1px solid #333; padding-bottom: 4px; }

        .control-group { margin: 8px 0; }
        label { display: block; font-size: 11px; color: #888; margin-bottom: 3px; }

        select, input[type="range"] {
            width: 100%;
            padding: 5px;
            background: #1a1a25;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
        }

        input[type="range"] { padding: 0; height: 5px; cursor: pointer; }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 6px 0;
        }
        .checkbox-group input { width: auto; }
        .checkbox-group label { margin: 0; font-size: 11px; }

        button {
            width: 100%;
            padding: 8px;
            margin-top: 8px;
            background: linear-gradient(135deg, #446 0%, #335 100%);
            border: 1px solid #557;
            border-radius: 5px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        button:hover { background: linear-gradient(135deg, #557 0%, #446 100%); }
        button.secondary { background: linear-gradient(135deg, #363 0%, #252 100%); border-color: #474; }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(15, 15, 25, 0.95);
            padding: 12px 15px;
            border-radius: 10px;
            font-size: 11px;
            border: 1px solid #333;
        }

        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(15, 15, 25, 0.95);
            padding: 15px;
            border-radius: 10px;
            font-size: 11px;
            border: 1px solid #333;
            min-width: 200px;
        }

        .stat-row { display: flex; justify-content: space-between; margin: 3px 0; }
        .stat-label { color: #888; }
        .stat-value { color: #8cf; font-weight: bold; }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: #8af;
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border-radius: 10px;
        }

        .proj-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            margin: 8px 0;
        }

        .proj-btn {
            padding: 6px 8px;
            font-size: 10px;
            background: #1a1a25;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            color: #aaa;
            transition: all 0.2s;
        }
        .proj-btn:hover { background: #252535; color: #fff; }
        .proj-btn.active { background: #335; border-color: #557; color: #8af; }

        .color-scheme {
            display: flex;
            gap: 4px;
            margin: 8px 0;
        }
        .color-btn {
            flex: 1;
            padding: 4px;
            font-size: 10px;
            background: #1a1a25;
            border: 1px solid #444;
            border-radius: 3px;
            cursor: pointer;
            color: #aaa;
        }
        .color-btn.active { background: #335; border-color: #557; color: #fff; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="loading">Loading fibration data...</div>

    <div id="controls">
        <h1>Calabi-Yau Fibration Explorer</h1>
        <div class="subtitle">v5.8 Multi-Layer | 500 Fibers | 8 Projections</div>

        <h2>Projection (8 Types)</h2>
        <div class="proj-grid">
            <button class="proj-btn active" data-proj="quintic_64d">Quintic 64D</button>
            <button class="proj-btn" data-proj="hopf_64d">Hopf 64D</button>
            <button class="proj-btn" data-proj="k3_128d">K3 128D</button>
            <button class="proj-btn" data-proj="mirror_128d">Mirror 128D</button>
            <button class="proj-btn" data-proj="fermat_192d">Fermat 192D</button>
            <button class="proj-btn" data-proj="torus_192d">Torus 192D</button>
            <button class="proj-btn" data-proj="conifold_256d">Conifold 256D</button>
            <button class="proj-btn" data-proj="cy3_512d">CY3 512D</button>
        </div>

        <h2>Display Layers</h2>
        <div class="checkbox-group">
            <input type="checkbox" id="showPoints" checked>
            <label for="showPoints">Point Cloud (19,683 points)</label>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="showFibers" checked>
            <label for="showFibers">Fiber Lines (ribbons)</label>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="showTubes">
            <label for="showTubes">Tube Meshes (first 100)</label>
        </div>

        <h2>Point Cloud</h2>
        <div class="control-group">
            <label>Size: <span id="pointSizeVal">1.0</span></label>
            <input type="range" id="pointSize" min="0.3" max="4" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>Opacity: <span id="pointOpacityVal">0.20</span></label>
            <input type="range" id="pointOpacity" min="0.05" max="0.8" step="0.05" value="0.20">
        </div>

        <h2>Fiber Ribbons</h2>
        <div class="control-group">
            <label>Count: <span id="fiberCountVal">100</span> / 500</label>
            <input type="range" id="fiberCount" min="10" max="500" step="10" value="100">
        </div>
        <div class="control-group">
            <label>Width: <span id="fiberWidthVal">1.5</span></label>
            <input type="range" id="fiberWidth" min="0.5" max="4" step="0.25" value="1.5">
        </div>
        <div class="control-group">
            <label>Opacity: <span id="fiberOpacityVal">0.75</span></label>
            <input type="range" id="fiberOpacity" min="0.2" max="1" step="0.05" value="0.75">
        </div>

        <h2>Color Scheme</h2>
        <div class="color-scheme">
            <button class="color-btn active" data-scheme="twilight">Twilight</button>
            <button class="color-btn" data-scheme="viridis">Viridis</button>
            <button class="color-btn" data-scheme="plasma">Plasma</button>
            <button class="color-btn" data-scheme="rainbow">Rainbow</button>
        </div>

        <h2>Animation</h2>
        <div class="checkbox-group">
            <input type="checkbox" id="autoRotate" checked>
            <label for="autoRotate">Auto Rotate</label>
        </div>
        <div class="control-group">
            <label>Speed: <span id="rotationSpeedVal">0.3</span></label>
            <input type="range" id="rotationSpeed" min="0" max="2" step="0.1" value="0.3">
        </div>

        <button id="resetCamera">Reset Camera</button>
        <button id="exportView" class="secondary">Export View (PNG)</button>
    </div>

    <div id="stats">
        <div class="stat-row"><span class="stat-label">Projection:</span><span id="statProj" class="stat-value">-</span></div>
        <div class="stat-row"><span class="stat-label">Embedding:</span><span id="statEmb" class="stat-value">-</span></div>
        <div class="stat-row"><span class="stat-label">Points:</span><span id="statPoints" class="stat-value">-</span></div>
        <div class="stat-row"><span class="stat-label">Fibers:</span><span id="statFibers" class="stat-value">-</span></div>
        <div class="stat-row"><span class="stat-label">Visible:</span><span id="statVisible" class="stat-value">-</span></div>
    </div>

    <div id="info">
        <div>Drag: rotate | Scroll: zoom | Right-drag: pan | Double-click: focus</div>
        <div style="margin-top: 4px; color: #666;">Fibration shows internal manifold structure from v5.8 training</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let pointCloud, fiberLines = [], tubeMeshes = [];
        let currentData = null;
        let currentScheme = 'twilight';

        const colorSchemes = {
            twilight: (t) => {
                const r = Math.sin(t * Math.PI) * 0.5 + 0.5;
                const g = Math.sin(t * Math.PI - Math.PI/3) * 0.3 + 0.2;
                const b = Math.cos(t * Math.PI * 0.5) * 0.5 + 0.5;
                return new THREE.Color(r, g, b);
            },
            viridis: (t) => {
                const r = 0.267 + t * 0.65;
                const g = 0.004 + t * 0.87;
                const b = 0.329 + (1-t) * 0.5;
                return new THREE.Color(Math.min(1, r), Math.min(1, g), Math.min(1, b));
            },
            plasma: (t) => {
                const r = 0.05 + t * 0.9;
                const g = t < 0.5 ? t * 0.5 : 0.25 + (t-0.5) * 1.5;
                const b = 0.53 - t * 0.4;
                return new THREE.Color(Math.min(1, r), Math.min(1, Math.max(0, g)), Math.max(0, b));
            },
            rainbow: (t) => new THREE.Color().setHSL(t * 0.8, 0.8, 0.5)
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 100);
            camera.position.set(2.5, 1.8, 2.5);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;

            // Lights
            scene.add(new THREE.AmbientLight(0x404050, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 5, 5);
            scene.add(dirLight);
            const backLight = new THREE.DirectionalLight(0x4466aa, 0.4);
            backLight.position.set(-5, -5, -5);
            scene.add(backLight);

            // Subtle grid
            const gridHelper = new THREE.GridHelper(2, 20, 0x222233, 0x181825);
            gridHelper.position.y = -1;
            scene.add(gridHelper);

            setupEventListeners();
            loadProjection('quintic_64d');
            animate();
        }

        function setupEventListeners() {
            // Projection buttons
            document.querySelectorAll('.proj-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.proj-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    loadProjection(btn.dataset.proj);
                });
            });

            // Color scheme buttons
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentScheme = btn.dataset.scheme;
                    if (currentData) updateColors();
                });
            });

            // Display toggles
            document.getElementById('showPoints').addEventListener('change', updateVisibility);
            document.getElementById('showFibers').addEventListener('change', updateVisibility);
            document.getElementById('showTubes').addEventListener('change', updateVisibility);

            // Point controls
            document.getElementById('pointSize').addEventListener('input', (e) => {
                document.getElementById('pointSizeVal').textContent = e.target.value;
                if (pointCloud) pointCloud.material.size = parseFloat(e.target.value) * 0.01;
            });

            document.getElementById('pointOpacity').addEventListener('input', (e) => {
                document.getElementById('pointOpacityVal').textContent = e.target.value;
                if (pointCloud) pointCloud.material.opacity = parseFloat(e.target.value);
            });

            // Fiber controls
            document.getElementById('fiberCount').addEventListener('input', (e) => {
                document.getElementById('fiberCountVal').textContent = e.target.value;
                updateFibers();
            });

            document.getElementById('fiberWidth').addEventListener('input', (e) => {
                document.getElementById('fiberWidthVal').textContent = e.target.value;
                fiberLines.forEach(line => {
                    if (line.material) line.material.linewidth = parseFloat(e.target.value);
                });
            });

            document.getElementById('fiberOpacity').addEventListener('input', (e) => {
                document.getElementById('fiberOpacityVal').textContent = e.target.value;
                fiberLines.forEach(line => {
                    if (line.material) line.material.opacity = parseFloat(e.target.value);
                });
            });

            // Animation
            document.getElementById('autoRotate').addEventListener('change', (e) => {
                controls.autoRotate = e.target.checked;
            });

            document.getElementById('rotationSpeed').addEventListener('input', (e) => {
                document.getElementById('rotationSpeedVal').textContent = e.target.value;
                controls.autoRotateSpeed = parseFloat(e.target.value);
            });

            // Buttons
            document.getElementById('resetCamera').addEventListener('click', () => {
                camera.position.set(2.5, 1.8, 2.5);
                controls.target.set(0, 0, 0);
                controls.update();
            });

            document.getElementById('exportView').addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = `calabi_yau_${currentData?.name || 'view'}.png`;
                link.href = renderer.domElement.toDataURL('image/png');
                link.click();
            });

            // Double-click to focus
            renderer.domElement.addEventListener('dblclick', (e) => {
                const rect = renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((e.clientX - rect.left) / rect.width) * 2 - 1,
                    -((e.clientY - rect.top) / rect.height) * 2 + 1
                );
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                if (pointCloud) {
                    const intersects = raycaster.intersectObject(pointCloud);
                    if (intersects.length > 0) {
                        controls.target.copy(intersects[0].point);
                    }
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        async function loadProjection(name) {
            document.getElementById('loading').style.display = 'block';

            try {
                const response = await fetch(`${name}.json`);
                currentData = await response.json();

                clearScene();
                createPointCloud(currentData.points);
                createFibers(currentData.smooth_fibers);
                createTubeMeshes(currentData.tube_meshes);

                // Update stats
                document.getElementById('statProj').textContent = currentData.name.split(' ')[0];
                document.getElementById('statEmb').textContent = currentData.embedding_dim || name.split('_')[1];
                document.getElementById('statPoints').textContent = currentData.n_points.toLocaleString();
                document.getElementById('statFibers').textContent = currentData.n_fibers;
                updateVisibleCount();

                updateVisibility();
            } catch (error) {
                console.error('Error loading projection:', error);
                document.getElementById('loading').textContent = 'Error loading data';
            }

            document.getElementById('loading').style.display = 'none';
        }

        function clearScene() {
            if (pointCloud) {
                scene.remove(pointCloud);
                pointCloud.geometry.dispose();
                pointCloud.material.dispose();
            }
            fiberLines.forEach(line => {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            });
            fiberLines = [];
            tubeMeshes.forEach(mesh => {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            });
            tubeMeshes = [];
        }

        function createPointCloud(points) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(points.length * 3);
            const colors = new Float32Array(points.length * 3);

            for (let i = 0; i < points.length; i++) {
                positions[i * 3] = points[i][0];
                positions[i * 3 + 1] = points[i][1];
                positions[i * 3 + 2] = points[i][2];

                const angle = Math.atan2(points[i][1], points[i][0]);
                const t = (angle + Math.PI) / (2 * Math.PI);
                const color = colorSchemes[currentScheme](t);

                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: parseFloat(document.getElementById('pointSize').value) * 0.01,
                vertexColors: true,
                transparent: true,
                opacity: parseFloat(document.getElementById('pointOpacity').value),
                sizeAttenuation: true
            });

            pointCloud = new THREE.Points(geometry, material);
            scene.add(pointCloud);
        }

        function createFibers(smoothFibers) {
            const fiberCount = parseInt(document.getElementById('fiberCount').value);
            const lineWidth = parseFloat(document.getElementById('fiberWidth').value);
            const opacity = parseFloat(document.getElementById('fiberOpacity').value);

            const count = Math.min(fiberCount, smoothFibers.length);

            for (let i = 0; i < count; i++) {
                const fiber = smoothFibers[i];
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(fiber.length * 3);

                for (let j = 0; j < fiber.length; j++) {
                    positions[j * 3] = fiber[j][0];
                    positions[j * 3 + 1] = fiber[j][1];
                    positions[j * 3 + 2] = fiber[j][2];
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const t = i / count;
                const color = colorSchemes[currentScheme](t);

                const material = new THREE.LineBasicMaterial({
                    color: color,
                    linewidth: lineWidth,
                    transparent: true,
                    opacity: opacity
                });

                const line = new THREE.Line(geometry, material);
                fiberLines.push(line);
                scene.add(line);
            }

            updateVisibleCount();
        }

        function createTubeMeshes(tubes) {
            if (!tubes) return;

            for (let i = 0; i < Math.min(100, tubes.length); i++) {
                const tube = tubes[i];
                const geometry = new THREE.BufferGeometry();

                const positions = new Float32Array(tube.vertices.length * 3);
                for (let j = 0; j < tube.vertices.length; j++) {
                    positions[j * 3] = tube.vertices[j][0];
                    positions[j * 3 + 1] = tube.vertices[j][1];
                    positions[j * 3 + 2] = tube.vertices[j][2];
                }

                const indices = new Uint32Array(tube.faces.flat());

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                geometry.computeVertexNormals();

                const t = i / 100;
                const color = colorSchemes[currentScheme](t);

                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide,
                    shininess: 40
                });

                const mesh = new THREE.Mesh(geometry, material);
                tubeMeshes.push(mesh);
                scene.add(mesh);
            }
        }

        function updateFibers() {
            if (!currentData) return;

            fiberLines.forEach(line => {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            });
            fiberLines = [];

            createFibers(currentData.smooth_fibers);
            updateVisibility();
        }

        function updateColors() {
            if (!currentData) return;

            // Update point colors
            if (pointCloud) {
                const colors = pointCloud.geometry.attributes.color.array;
                const positions = pointCloud.geometry.attributes.position.array;

                for (let i = 0; i < colors.length / 3; i++) {
                    const x = positions[i * 3];
                    const y = positions[i * 3 + 1];
                    const angle = Math.atan2(y, x);
                    const t = (angle + Math.PI) / (2 * Math.PI);
                    const color = colorSchemes[currentScheme](t);

                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                pointCloud.geometry.attributes.color.needsUpdate = true;
            }

            // Update fiber colors
            const count = fiberLines.length;
            fiberLines.forEach((line, i) => {
                const t = i / count;
                line.material.color = colorSchemes[currentScheme](t);
            });

            // Update tube colors
            tubeMeshes.forEach((mesh, i) => {
                const t = i / 100;
                mesh.material.color = colorSchemes[currentScheme](t);
            });
        }

        function updateVisibility() {
            const showPoints = document.getElementById('showPoints').checked;
            const showFibers = document.getElementById('showFibers').checked;
            const showTubes = document.getElementById('showTubes').checked;

            if (pointCloud) pointCloud.visible = showPoints;
            fiberLines.forEach(line => line.visible = showFibers);
            tubeMeshes.forEach(mesh => mesh.visible = showTubes);

            updateVisibleCount();
        }

        function updateVisibleCount() {
            const showFibers = document.getElementById('showFibers').checked;
            const count = showFibers ? fiberLines.length : 0;
            document.getElementById('statVisible').textContent = `${count} fibers`;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
